#!/usr/bin/env ruby
# encoding: UTF-8
require 'rubygems'
require 'bundler/setup'
require 'aws-sdk-core'
require 'thor'
require 'time'
require 'logger'
require 'json'
require 'base64'
require_relative 'lib/settings'

class KmsEncrypt < Thor
  Settings.load!(File.dirname(__FILE__) + '/config/hcentive-kms.yml')
	# TODO : move logging to a mixin
	loghome = Settings.logger[:home]
	Dir.mkdir(loghome) unless Dir.exist?(loghome)
	loghome.concat(Settings.logger[:file])
	logfile = File.open(loghome, "a+")
	@@logger = Logger.new(logfile, 'daily')
	@@logger = Logger.new(logfile, 'weekly')
	@@logger = Logger.new(logfile, 'monthly')
	@@logger.level = Logger::INFO
	@@logger.formatter = proc do |severity, datetime, progname, msg|
		"[#{datetime}] : #{severity} : #{progname} - #{msg}\n"
	end

  desc "encrypt", "Encrypt plaintext with supplied key alias; use product, tenant, stack and context to build encryption context"
	method_option :product, :required => true, :aliases => "-p", :type => :string, :desc => "product - name of the product for which the password is being encrypted"
	method_option :tenant, :required => true, :aliases => "-t", :type => :string, :desc => "tenant - name of the tenant of the product"
  method_option :stack, :required => true, :aliases => "-s", :type => :string, :desc => "stack - dev, qa, sit, uat, production"
  method_option :context, :required => true, :aliases => "-c", :type => :string, :desc => "context - unique context for the plaintext being encrypted; for example, hostname of the application server"
  method_option :keyalias, :required => true, :aliases => "-k", :type => :string, :desc => "keyalias - encryption key alias"
  method_option :plaintext, :required => true, :aliases => "-x", :type => :string, :desc => "plaintext - text to be encrypted"
  def encrypt
    @@logger.progname = "#{self.class.name}:#{__method__.to_s}"
		@@logger.info {"[Start] #{__method__.to_s}"}

    begin
      kms = Aws::KMS::Client.new(region: Settings.aws[:region])
      # ec = build_encryption_context(:product, :tenant, :stack, :context)
      resp = kms.encrypt({
        key_id: options[:keyalias],
        plaintext: options[:plaintext],
        encryption_context: {
          "product" => options[:product],
          "tenant" => options[:tenant],
          "stack" => options[:stack],
          "context" => options[:context]
        }
      })
    rescue Aws::KMS::Errors::ServiceError, Aws::Errors::MissingCredentialsError => e
      @@logger.error "KMS startup failed - #{e.message}"
      e.backtrace.each { |line| @@logger.error line }
      raise e
    ensure
      @@logger.info {"Instantiating KMS"}
    end
    @@logger.info {"[Stop] #{__method__.to_s}"}
    puts Base64.encode64(resp.ciphertext_blob)
  end

  desc "decrypt", "Decrypt base64 encoded ciphertext with supplied key alias; use product, tenant, stack and context to build encryption context"
	method_option :product, :required => true, :aliases => "-p", :type => :string, :desc => "product - name of the product for which the password is being encrypted"
	method_option :tenant, :required => true, :aliases => "-t", :type => :string, :desc => "tenant - name of the tenant of the product"
  method_option :stack, :required => true, :aliases => "-s", :type => :string, :desc => "stack - dev, qa, sit, uat, production"
  method_option :context, :required => true, :aliases => "-c", :type => :string, :desc => "context - unique context for the plaintext being encrypted; for example, hostname of the application server"
  method_option :ciphertext, :required => true, :aliases => "-x", :type => :string, :desc => "ciphertext - Base64 encoded text to be decrypted"
  def decrypt
    @@logger.progname = "#{self.class.name}:#{__method__.to_s}"
		@@logger.info {"[Start] #{__method__.to_s}"}

    begin
      kms = Aws::KMS::Client.new(region: Settings.aws[:region])
      # ec = build_encryption_context(:product, :tenant, :stack, :context)
      resp = kms.decrypt({
        ciphertext_blob: Base64.decode64(options[:ciphertext]),
        encryption_context: {
          "product" => options[:product],
          "tenant" => options[:tenant],
          "stack" => options[:stack],
          "context" => options[:context]
        }
      })
    rescue Aws::KMS::Errors::ServiceError, Aws::Errors::MissingCredentialsError => e
      @@logger.error "KMS startup failed - #{e.message}"
      e.backtrace.each { |line| @@logger.error line }
      raise e
    ensure
      @@logger.info {"Instantiating KMS"}
    end
    @@logger.info {"[Stop] #{__method__.to_s}"}
    puts resp.plaintext
  end

  no_tasks do
    def build_encryption_context(product, tenant, stack, context)
      ec_hash = {
                  :product =>   product,
                  :tenant  =>   tenant,
                  :stack   =>   stack,
                  :context =>   context
               }
      return JSON.generate(ec_hash).to_json
    end
  end
end

KmsEncrypt.start
